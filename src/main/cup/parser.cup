package lyc.compiler;

import java_cup.runtime.*;
import lyc.compiler.files.SymbolTableGenerator;
import lyc.compiler.files.IntermediateCodeGenerator;
import java.util.*;

class Parser;

parser code {:
    private final SymbolTableGenerator symbolTable = new SymbolTableGenerator();
:}

/*** Elementos Terminales ***/

//Operadores aritméticos
terminal PLUS;
terminal SUB;
terminal MULT;
terminal DIV;

//Operador de asignación
terminal ASSIG;

//Operadores relacionales
terminal EQUAL;
terminal NOT_EQUAL;
terminal LESS_EQUAL;
terminal GREATER_EQUAL;
terminal LESS;
terminal GREATER;

//Operadores lógicos
terminal AND;
terminal OR;
terminal NOT;

//Delimitadores 
terminal OPEN_BRACKET;
terminal CLOSE_BRACKET;
terminal OPEN_CURLY_BRACKET;
terminal CLOSE_CURLY_BRACKET;
terminal OPEN_SQUARE_BRACKET;
terminal CLOSE_SQUARE_BRACKET;
terminal COMMA;
terminal COLON;
terminal SEMI_COLON;

//Palabras clave
terminal WHILE;
terminal IF;
terminal ELSE;
terminal INIT;
terminal TYPE_INT;
terminal TYPE_FLOAT;
terminal TYPE_STRING;
terminal READ;
terminal WRITE;

//Funciones especiales del lenguaje
terminal EQUAL_EXPRESSIONS;
terminal TRIANGLE_AREA_MAXIMUM;

//Constantes  
terminal String INTEGER_CONSTANT;
terminal String FLOAT_CONSTANT;
terminal String STRING_CONSTANT;
terminal String BOOLEAN_CONSTANT;

//Identificadores
terminal String IDENTIFIER;


// ----------------------------------------------------
// No terminales
// ----------------------------------------------------
non terminal program;
non terminal statements;
non terminal statement;
non terminal assignment;
non terminal if_statement;
non terminal else_clause;
non terminal while_statement;
non terminal read_statement;
non terminal write_statement;
non terminal expression;
non terminal term;
non terminal factor;
non terminal condition;
non terminal simple_condition;
non terminal compound_condition;
non terminal variable_declaration;
non terminal variable_declaration_list;
non terminal init_block;
non terminal String identifier_list;
non terminal type_specifier;
non terminal triangle;
non terminal point;
non terminal Object expression_list;

// ----------------------------------------------------
// Start Symbol
// ----------------------------------------------------
start with program;

// ----------------------------------------------------
// Reglas del parser
// ----------------------------------------------------

program ::= statements 
                    {: 
                        System.out.println("Inicio del análisis");
                    :};

statements ::= /* vacío */ 
             | statements statement;

statement ::= assignment
            | if_statement
            | while_statement
            | read_statement
            | write_statement
            | init_block;   

assignment ::=  IDENTIFIER:id ASSIG expression:e
                    {: 
                        SymbolTableGenerator.Symbol sym_id = SymbolTableGenerator.getSymbol(id);
                        String id_type = sym_id.getType();

                        Map<String, Object> eMap = (Map<String, Object>) e;
                        String eType = (String) eMap.get("type");
                        String eStr = (String) eMap.get("value"); 

                        String aux = eStr; 

                        if (!eType.equals(id_type) && !id_type.equals("VARIABLE")) throw new RuntimeException("Asignacion incompatibles: " + id_type + " = " + eType);
 

                        if (eStr.length() >= 2 && eStr.charAt(0) == '(' && eStr.charAt(eStr.length() - 1) == ')') { 
                            aux = eStr.substring(1, eStr.length() - 1); 
                        } 

                        System.out.println("[ASSIGNMENT] Id := Expression -> " + id + " := " + aux); 
                        if(!symbolTable.existsDynamic(id) && !symbolTable.exists(id)) throw new RuntimeException("Variable no declarada: " + id); 

                        IntermediateCodeGenerator.addTerceto("ASSIGN", id, aux); 
                        RESULT = aux; 
                    :}
                |  IDENTIFIER:id ASSIG STRING_CONSTANT:strc
                    {:
                        System.out.println("[ASSIGNMENT] Id := String Constant -> " + id + " := " + strc); 
                      
                        SymbolTableGenerator.Symbol sym_id = SymbolTableGenerator.getSymbol(id);
                        SymbolTableGenerator.Symbol sym_strc = SymbolTableGenerator.getSymbol(strc);

                        String id_type = sym_id.getType();
                        if (!id_type.equals("VARIABLE") && !id_type.equals("CTE_STRING") && !id_type.equals("STRING") && !id_type.equals("String")) throw new RuntimeException("Asignacion incompatible. El tipo de la variable " + sym_id.getName() + ": " + id_type + " no corresponde con el tipo de la expresion " + sym_strc.getName() + ": " + sym_strc.getType());
                       
                        symbolTable.updateVariableS(id, "String", sym_strc.getValue(), sym_strc.getLength()); 

                        IntermediateCodeGenerator.addTerceto("ASSIGN", id, strc);
                        RESULT = strc;
                    :};

if_statement ::=
                IF OPEN_BRACKET condition:c CLOSE_BRACKET
                    {:
                        IntermediateCodeGenerator.addTerceto("IF_FALSE", "[" + IntermediateCodeGenerator.getLastIndex() + "]", "[PENDIENTE]");
                        IntermediateCodeGenerator.pushSalto(IntermediateCodeGenerator.getLastIndex());  // guado indice
                    :}
                OPEN_CURLY_BRACKET statements CLOSE_CURLY_BRACKET
                else_clause
                    {:
                        if (!IntermediateCodeGenerator.isSaltoEmpty()) {
                            int tercetoPendiente = IntermediateCodeGenerator.popSalto();    
                            int finIfElse = IntermediateCodeGenerator.getNextIndex();
                            IntermediateCodeGenerator.completarSalto(tercetoPendiente, finIfElse);  
                        }
                    :};

else_clause ::= /* vacío */
                | ELSE
                    {:  
                        IntermediateCodeGenerator.addTerceto("BRANCH", null, "[PENDIENTE]");       
                        if (!IntermediateCodeGenerator.isSaltoEmpty()) {
                            int ifFalsePendiente = IntermediateCodeGenerator.popSalto();
                            int inicioElse = IntermediateCodeGenerator.getNextIndex();
                            IntermediateCodeGenerator.completarSalto(ifFalsePendiente, inicioElse);
                        }
                        IntermediateCodeGenerator.pushSalto(IntermediateCodeGenerator.getLastIndex());
                    :}
                OPEN_CURLY_BRACKET statements CLOSE_CURLY_BRACKET;                    


while_statement ::=
    WHILE
    {:
        IntermediateCodeGenerator.pushSalto(IntermediateCodeGenerator.getNextIndex());
    :}
    OPEN_BRACKET condition:cond CLOSE_BRACKET
    {:
        IntermediateCodeGenerator.addTerceto("IF_FALSE", "[" + IntermediateCodeGenerator.getLastIndex() + "]", "[PENDIENTE]");
        IntermediateCodeGenerator.pushSalto(IntermediateCodeGenerator.getLastIndex());
    :}
    OPEN_CURLY_BRACKET statements CLOSE_CURLY_BRACKET
    {:
        int ifFalsePendiente = IntermediateCodeGenerator.popSalto();
        int inicioWhile = IntermediateCodeGenerator.popSalto();
        IntermediateCodeGenerator.addTerceto("BRANCH", null, "[" + inicioWhile + "]");
        int finWhile = IntermediateCodeGenerator.getNextIndex();
        IntermediateCodeGenerator.completarSalto(ifFalsePendiente, finWhile);
    :};

read_statement ::= READ OPEN_BRACKET IDENTIFIER:id CLOSE_BRACKET 
                    {: 
                        System.out.println("[READ]  ( Identifier ): " + id); 
                        if(!symbolTable.existsDynamic(id) && !symbolTable.exists(id)) throw new RuntimeException("Variable no declarada: " + id);
                        IntermediateCodeGenerator.addTerceto("READ", id, null);
                    :};

write_statement ::= WRITE OPEN_BRACKET expression:exp CLOSE_BRACKET 
                    {: 
                        System.out.println("[WRITE] ( Expression ): " + exp); 
                        IntermediateCodeGenerator.addTerceto("WRITE", exp, null);
                    :} 
                | WRITE OPEN_BRACKET STRING_CONSTANT:sc CLOSE_BRACKET {: 
                        System.out.println("[WRITE] ( String Constante ): " + sc); 
                        IntermediateCodeGenerator.addTerceto("WRITE", sc, null);
                    :};

expression ::= expression:left PLUS term:right
                    {:
                        System.out.println("[EXPRESSION] Expresion + Term");

                        Map<String, Object> l = (Map<String, Object>) left;
                        Map<String, Object> r = (Map<String, Object>) right;

                        String typeL = (String) l.get("type");
                        String typeR = (String) r.get("type");

                        if (!typeL.equals(typeR)) throw new RuntimeException("Tipos incompatibles en suma: " + typeL + " + " + typeR);

                        Object terceto = IntermediateCodeGenerator.addTerceto("ADD", l.get("value"), r.get("value"));

                        Map<String, Object> result = new HashMap<>();
                        result.put("value", terceto);
                        result.put("type", typeL);
                        RESULT = result;
                    :}
                | expression:left SUB term:right 
                    {: 
                        System.out.println("[EXPRESSION] Expresion - Term"); 
                        
                        Map<String, Object> l = (Map<String, Object>) left;
                        Map<String, Object> r = (Map<String, Object>) right;

                        String typeL = (String) l.get("type");
                        String typeR = (String) r.get("type");

                        if (!typeL.equals(typeR)) throw new RuntimeException("Tipos incompatibles en resta: " + typeL + " - " + typeR);

                        Object terceto = IntermediateCodeGenerator.addTerceto("SUB", l.get("value"), r.get("value"));

                        Map<String, Object> result = new HashMap<>();
                        result.put("value", terceto);
                        result.put("type", typeL);
                        RESULT = result;
                    :}
                | term:term
                    {: 
                        System.out.println("[EXPRESSION] Term"); 
                        RESULT = term;
                    :}
                | TRIANGLE_AREA_MAXIMUM OPEN_BRACKET triangle:t1 SEMI_COLON triangle:t2 CLOSE_BRACKET 
                    {: 
                        System.out.println("[EXPRESSION] triangleAreaMaximum ( Triangle ; Triangle )");
                        Object t1_area = IntermediateCodeGenerator.addTerceto("AREA", t1, null);
                        Object t2_area = IntermediateCodeGenerator.addTerceto("AREA", t2, null);

                        Object terceto = IntermediateCodeGenerator.addTerceto("MAX", t1_area, t2_area);

                        Map<String, Object> result = new HashMap<>();
                        result.put("value", terceto);
                        result.put("type", "Float");
                        RESULT = result;
                    :}
                | EQUAL_EXPRESSIONS OPEN_BRACKET expression_list:el CLOSE_BRACKET
                    {: 
                        String res = lyc.compiler.files.ExpressionUtils.equalExpressions(el);
                        System.out.println("[EXPRESSION] equalExpressions ( Expression List ): " + el);

                        Map<String, Object> result = new HashMap<>();
                        result.put("value", res);
                        result.put("type", "Bolean");
                        RESULT = result;
                    :};

triangle ::= OPEN_SQUARE_BRACKET point:p1 SEMI_COLON point:p2 SEMI_COLON point:p3 CLOSE_SQUARE_BRACKET 
                    {: 
                        System.out.println("[TRIANGLE] [point ; point ; point ]");
                        Object temp_tri = IntermediateCodeGenerator.addTerceto("TRI_P1_P2", p1, p2);

                        Object terceto = IntermediateCodeGenerator.addTerceto("TRIANGLE", temp_tri, p3);

                        Map<String, Object> result = new HashMap<>();
                        result.put("value", terceto);
                        result.put("type", "Float");
                        RESULT = result;
                    :};

point ::= expression:x COMMA expression:y 
                    {: 
                        System.out.println("[POINT] Expression , Expression");

                        Object terceto = IntermediateCodeGenerator.addTerceto("POINT", x, y);

                        Map<String, Object> result = new HashMap<>();
                        result.put("value", terceto);
                        result.put("type", "Float");
                        RESULT = result;
                    :};

expression_list ::= expression:exp
                    {: 
                        System.out.println("[EXPRESSION LIST] Expression");
                        java.util.List<Object> list = new java.util.ArrayList<>();
                        list.add(exp);
                        RESULT = list;
                    :}
                | expression_list:list COMMA expression:exp
                    {: 
                        System.out.println("[EXPRESSION LIST] Expression List , Expression");
                        java.util.List<Object> tmp = (java.util.List<Object>) list;
                        tmp.add(exp);
                        RESULT = tmp;
                    :};

term ::= term:left MULT factor:right 
                    {: 
                        System.out.println("[TERM] Term * Factor"); 

                        Map<String, Object> l = (Map<String, Object>) left;
                        Map<String, Object> r = (Map<String, Object>) right;

                        String typeL = (String) l.get("type");
                        String typeR = (String) r.get("type");

                        if (!typeL.equals(typeR)) throw new RuntimeException("Tipos incompatibles en multiplicacion: " + typeL + " * " + typeR);

                        Object terceto = IntermediateCodeGenerator.addTerceto("MULT", l.get("value"), r.get("value"));

                        Map<String, Object> result = new HashMap<>();
                        result.put("value", terceto);
                        result.put("type", typeL);
                        RESULT = result;
                    :}
                | term:left DIV factor:right 
                    {: 
                        System.out.println("[TERM] Term / Factor"); 

                        Map<String, Object> l = (Map<String, Object>) left;
                        Map<String, Object> r = (Map<String, Object>) right;

                        String typeL = (String) l.get("type");
                        String typeR = (String) r.get("type");

                        if (!typeL.equals(typeR)) throw new RuntimeException("Tipos incompatibles en division: " + typeL + " / " + typeR);

                        Object terceto = IntermediateCodeGenerator.addTerceto("DIV", l.get("value"), r.get("value"));

                        Map<String, Object> result = new HashMap<>();
                        result.put("value", terceto);
                        result.put("type", typeL);
                        RESULT = result;
                    :}
                | factor:value 
                    {: 
                        System.out.println("[TERM] Factor");
                        RESULT = value; 
                    :};

factor ::= IDENTIFIER:id 
                    {: 
                        System.out.println("[FACTOR] Identificador: " + id);

                        SymbolTableGenerator.Symbol sym_id = SymbolTableGenerator.getSymbol(id);

                        Map<String, Object> result = new HashMap<>();
                        result.put("value", id);
                        result.put("type", sym_id.getType());
                        RESULT = result;

                    :}
                | INTEGER_CONSTANT:intc {: 
                        System.out.println("[FACTOR] Constante Entera: " + intc);
                        
                        SymbolTableGenerator.Symbol sym_intc = SymbolTableGenerator.getSymbol(intc);

                        Map<String, Object> result = new HashMap<>();
                        result.put("value", intc);
                        result.put("type", "Integer");
                        RESULT = result;
                    :}
                | FLOAT_CONSTANT:floatc 
                    {: 
                        System.out.println("[FACTOR] Constante Float: " + floatc);
                        
                        SymbolTableGenerator.Symbol sym_floatc = SymbolTableGenerator.getSymbol(floatc);

                        Map<String, Object> result = new HashMap<>();
                        result.put("value", floatc);
                        result.put("type", "Float");
                        RESULT = result;
                    :}
                | OPEN_BRACKET expression:exp CLOSE_BRACKET 
                    {: 
                        System.out.println("[FACTOR] ( Expression )"); 
                        RESULT = exp; 
                    :};

condition ::= simple_condition
                | NOT simple_condition 
                    {: 
                        System.out.println("[CONDITION] NOT Simple Condition"); 
                    :}
                | compound_condition 
                    {: 
                        System.out.println("[CONDITION] Compound Condition"); 
                    :};

simple_condition ::= expression:left LESS expression:right
                    {: 
                        System.out.println("[SIMPLE CONDITION] Expression < Expression"); 
                        RESULT = IntermediateCodeGenerator.addTerceto("LESS", left, right);
                    :}
                | expression:left GREATER expression:right
                    {: 
                        System.out.println("[SIMPLE CONDITION] Expression > Expression"); 
                        RESULT = IntermediateCodeGenerator.addTerceto("GREATER", left, right);
                    :}
                | expression:left EQUAL expression:right
                    {: 
                        System.out.println("[SIMPLE CONDITION] Expression == Expression");
                        RESULT = IntermediateCodeGenerator.addTerceto("EQUAL", left, right);
                    :}
                | expression:left NOT_EQUAL expression:right
                    {: 
                        System.out.println("[SIMPLE CONDITION] Expression != Expression"); 
                        RESULT = IntermediateCodeGenerator.addTerceto("NOT_EQUAL", left, right);
                    :}
                | expression:left LESS_EQUAL expression:right
                    {: 
                        System.out.println("[SIMPLE CONDITION] Expression <= Expression"); 
                        RESULT = IntermediateCodeGenerator.addTerceto("LESS_EQUAL", left, right);
                    :}
                | expression:left GREATER_EQUAL expression:right
                    {: 
                        System.out.println("[SIMPLE CONDITION] Expression >= Expression"); 
                        RESULT = IntermediateCodeGenerator.addTerceto("GREATER_EQUAL", left, right);
                    :};

compound_condition ::= simple_condition:left AND simple_condition:right 
                    {: 
                        System.out.println("[COMPOUND CONDITION] Condition AND Condition"); 
                        //if (!lyc.compiler.files.Utils.isBoolean(left) || !lyc.compiler.files.Utils.isBoolean(right)) throw new RuntimeException("Operador AND aplicado a expresiones no booleanas");
                    :}
                | simple_condition:left OR simple_condition:right
                    {: 
                        System.out.println("[COMPOUND CONDITION] Condition OR Condition");
                        //if (!lyc.compiler.files.Utils.isBoolean(left) || !lyc.compiler.files.Utils.isBoolean(right)) throw new RuntimeException("Operador AND aplicado a expresiones no booleanas"); 
                    :};

init_block ::= INIT OPEN_CURLY_BRACKET variable_declaration_list CLOSE_CURLY_BRACKET 
                    {: 
                        System.out.println("[INIT BLOCK] Init { variable_declaration_list }"); 
                    :};

variable_declaration ::= identifier_list:list COLON type_specifier:type 
                    {: 
                        System.out.println("[VARIABLE DECLARATION] identifier_list : type_specifier");
                        String[] ids = ((String)list).split(",");
                        for(String id : ids){
                            if(id.length() > lyc.compiler.constants.Constants.STRING_MAX_LENGTH) throw new RuntimeException("Nombre de identificador demasiado largo: " + id);
                            if(symbolTable.existsDynamic(id)) throw new RuntimeException("Variable ya declarada: " + id);
                            symbolTable.insertVariablesDynamic(id, type);
                            symbolTable.updateVariable(id, type);
                        }
                    :};

variable_declaration_list ::= variable_declaration
                    {: 
                        System.out.println("[VAR DECLARATION LIST] variable_declaration");
                    :}
                | variable_declaration_list variable_declaration
                    {: 
                        System.out.println("[VAR DECLARATION LIST] variable_declaration_list variable_declaration");
                    :};

identifier_list ::= IDENTIFIER:id 
                    {: 
                        System.out.println("[IDENTIFIER LIST] Identifier");
                        if(id.length() > lyc.compiler.constants.Constants.STRING_MAX_LENGTH) 
                            throw new RuntimeException("Nombre de identificador demasiado largo: " + id); 
                        RESULT = id; 
                    :}
                | identifier_list:list COMMA IDENTIFIER:id 
                    {: 
                        System.out.println("[IDENTIFIER LIST] identifier_list , Identifier");
                        if(id.length() > lyc.compiler.constants.Constants.STRING_MAX_LENGTH) 
                            throw new RuntimeException("Nombre de identificador demasiado largo: " + id); 
                        RESULT = list + "," + id; 
                    :};

type_specifier ::= TYPE_INT 
                    {: 
                        System.out.println("[TYPE SPECIFIER] Type Integer" );
                        RESULT = "Integer"; 
                    :}
                | TYPE_FLOAT 
                    {: 
                        System.out.println("[TYPE SPECIFIER] Type Float" );
                        RESULT = "Float"; 
                    :}
                | TYPE_STRING 
                    {: 
                        System.out.println("[TYPE SPECIFIER] Type String" );
                        RESULT = "String"; 
                    :};