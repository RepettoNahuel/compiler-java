package lyc.compiler;

import java_cup.runtime.*;
import lyc.compiler.files.SymbolTableGenerator;

class Parser;


/*** Elementos Terminales ***/

//Operadores aritméticos
terminal PLUS;
terminal SUB;
terminal MULT;
terminal DIV;

//Operador de asignación
terminal ASSIG;

//Operadores relacionales
terminal EQUAL;
terminal NOT_EQUAL;
terminal LESS_EQUAL;
terminal GREATER_EQUAL;
terminal LESS;
terminal GREATER;

//Operadores lógicos
terminal AND;
terminal OR;
terminal NOT;

//Delimitadores 
terminal OPEN_BRACKET;
terminal CLOSE_BRACKET;
terminal OPEN_CURLY_BRACKET;
terminal CLOSE_CURLY_BRACKET;
terminal OPEN_SQUARE_BRACKET;
terminal CLOSE_SQUARE_BRACKET;
terminal COMMA;
terminal COLON;
terminal SEMI_COLON;

//Palabras clave
terminal WHILE;
terminal IF;
terminal ELSE;
terminal INIT;
terminal TYPE_INT;
terminal TYPE_FLOAT;
terminal TYPE_STRING;
terminal READ;
terminal WRITE;

//Funciones especiales del lenguaje
terminal EQUAL_EXPRESSIONS;
terminal TRIANGLE_AREA_MAXIMUM;

//Constantes  
terminal String INTEGER_CONSTANT;
terminal String FLOAT_CONSTANT;
terminal String STRING_CONSTANT;

//Identificadores
terminal String IDENTIFIER;


// ----------------------------------------------------
// No terminales
// ----------------------------------------------------
non terminal program;
non terminal statements;
non terminal statement;
non terminal assignment;
non terminal if_statement;
non terminal else_clause;
non terminal while_statement;
non terminal read_statement;
non terminal write_statement;
non terminal expression;
non terminal term;
non terminal factor;
non terminal condition;
non terminal simple_condition;
non terminal compound_condition;
non terminal variable_declaration;
non terminal variable_declaration_list;
non terminal init_block;
non terminal String identifier_list;
non terminal type_specifier;
non terminal triangle;
non terminal point;

// ----------------------------------------------------
// Start Symbol
// ----------------------------------------------------
start with program;

// ----------------------------------------------------
// Reglas del parser
// ----------------------------------------------------

program ::= statements {: System.out.println("Inicio del análisis"); :};

statements ::= /* vacío */ 
             | statements statement;

statement ::= assignment
            | if_statement
            | while_statement
            | read_statement
            | write_statement
            | init_block;   

assignment ::=  IDENTIFIER:id ASSIG expression:e {: 
               System.out.println("[ASSIGN] RESULT de expression: " + e);
               lyc.compiler.files.SymbolTableGenerator.Symbol simbolo = lyc.compiler.files.SymbolTableGenerator.getSymbol(id);
               String valorAsignar = String.valueOf(e);
               lyc.compiler.files.SymbolTableGenerator.Symbol origen = lyc.compiler.files.SymbolTableGenerator.getSymbol(valorAsignar);
               if (origen != null && origen.getValue() != null && !origen.getValue().isEmpty()) {
                   valorAsignar = origen.getValue();
               }
               if (simbolo != null) {
                  simbolo.setValue(valorAsignar);
               }
               System.out.println("Asignación: " + id + " := " + valorAsignar); 
                 :}
                |  IDENTIFIER:id ASSIG STRING_CONSTANT:strc{: 
               lyc.compiler.files.SymbolTableGenerator.Symbol simbolo = lyc.compiler.files.SymbolTableGenerator.getSymbol(id);
               if (simbolo != null) {
                  simbolo.setValue(String.valueOf(strc));
               }
               System.out.println("Constante String: " + strc); 
               System.out.println("Asignación: " + id + " := " + strc); 
                 :}
                 ;

if_statement ::= IF OPEN_BRACKET condition CLOSE_BRACKET OPEN_CURLY_BRACKET statements CLOSE_CURLY_BRACKET else_clause {: 
                    System.out.println("If con condición"); 
                 :};

else_clause ::= /* vacío */ 
              | ELSE OPEN_CURLY_BRACKET statements CLOSE_CURLY_BRACKET {: 
                    System.out.println("Else"); 
                 :};

while_statement ::= WHILE OPEN_BRACKET condition CLOSE_BRACKET OPEN_CURLY_BRACKET statements CLOSE_CURLY_BRACKET {: 
                    System.out.println("While con condición"); 
                 :};

read_statement ::= READ OPEN_BRACKET IDENTIFIER:id CLOSE_BRACKET {: 
                    System.out.println("Read de variable: " + id); 
                 :};

write_statement ::= WRITE OPEN_BRACKET expression:exp CLOSE_BRACKET {: 
                    System.out.println("Write de: " + exp); 
                 :} 
                 | WRITE OPEN_BRACKET STRING_CONSTANT:sc CLOSE_BRACKET {: 
                    System.out.println("Write de: " + sc); 
                 :};

expression ::= expression:left PLUS term:right {: System.out.println("Suma"); RESULT = left + "+" + right; :}
            | expression:left SUB term:right {: System.out.println("Resta"); RESULT = left + "-" + right; :}
            | term:term {: RESULT = term; :}
            | TRIANGLE_AREA_MAXIMUM OPEN_BRACKET triangle:t1 SEMI_COLON triangle:t2 CLOSE_BRACKET {: 
                double area1 = lyc.compiler.files.GeometryUtils.calculateTriangleArea(t1);
                double area2 = lyc.compiler.files.GeometryUtils.calculateTriangleArea(t2);
                double maxArea = Math.max(area1, area2);
                System.out.println("Área máxima: " + maxArea);
                RESULT = String.valueOf(maxArea);
            :}
            ;

triangle ::= OPEN_SQUARE_BRACKET point:p1 SEMI_COLON point:p2 SEMI_COLON point:p3 CLOSE_SQUARE_BRACKET {: 
                RESULT = new Object[]{p1, p2, p3}; 
            :};

point ::= expression:x COMMA expression:y {: RESULT = new Object[]{x, y}; :};

term ::= term:left MULT factor:right {: System.out.println("Multiplicación"); RESULT = left + "*" + right; :}
       | term:left DIV factor:right {: System.out.println("División"); RESULT = left + "/" + right; :}
       | factor:value {: RESULT = value; :};

factor ::= IDENTIFIER:id {: 
    System.out.println("[FACTOR] Identificador: " + id);
    RESULT = id;
:}
| INTEGER_CONSTANT:intc {: 
    System.out.println("[FACTOR] Constante Entera: " + intc);
    RESULT = intc;
:}
| FLOAT_CONSTANT:floatc {: 
    System.out.println("[FACTOR] Constante Float: " + floatc);
    RESULT = floatc;
:}
| OPEN_BRACKET expression:exp CLOSE_BRACKET {: System.out.println("Factor entre paréntesis"); RESULT = "(" + exp + ")"; :};

condition ::= simple_condition
            | NOT simple_condition {: System.out.println("Condición NOT"); :}
            | compound_condition {: System.out.println("Condición compuesta"); :};

simple_condition ::= expression LESS expression {: System.out.println("Condición: <"); :}
                   | expression GREATER expression {: System.out.println("Condición: >"); :}
                   | expression EQUAL expression {: System.out.println("Condición: =="); :}
                   | expression NOT_EQUAL expression {: System.out.println("Condición: !="); :}
                   | expression LESS_EQUAL expression {: System.out.println("Condición: <="); :}
                   | expression GREATER_EQUAL expression {: System.out.println("Condición: >="); :};

compound_condition ::= simple_condition AND simple_condition {: System.out.println("Condición AND"); :}
                     | simple_condition OR simple_condition {: System.out.println("Condición OR"); :};

init_block ::= INIT OPEN_CURLY_BRACKET variable_declaration_list CLOSE_CURLY_BRACKET {: 
                    System.out.println("Inicio de bloque Init"); 
              :};

variable_declaration ::= identifier_list:list COLON type_specifier:type {: 
                            System.out.println("Declaración de variable(s): " + list + " tipo: " + type); 
                            SymbolTableGenerator.insertVariables((String)list, (String)type);
                        :};

variable_declaration_list ::= variable_declaration
                            | variable_declaration_list variable_declaration;

identifier_list ::= IDENTIFIER:id {: RESULT = id; :}
                  | identifier_list:list COMMA IDENTIFIER:id {: RESULT = list + "," + id; :};

type_specifier ::= TYPE_INT {: RESULT = "Int"; :}
                 | TYPE_FLOAT {: RESULT = "Float"; :}
                 | TYPE_STRING {: RESULT = "String"; :};