package lyc.compiler;

import java_cup.runtime.*;
import lyc.compiler.files.SymbolTableGenerator;
import lyc.compiler.files.IntermediateCodeGenerator;

class Parser;

parser code {:
    private final SymbolTableGenerator symbolTable = new SymbolTableGenerator();
:}

/*** Elementos Terminales ***/

//Operadores aritméticos
terminal PLUS;
terminal SUB;
terminal MULT;
terminal DIV;

//Operador de asignación
terminal ASSIG;

//Operadores relacionales
terminal EQUAL;
terminal NOT_EQUAL;
terminal LESS_EQUAL;
terminal GREATER_EQUAL;
terminal LESS;
terminal GREATER;

//Operadores lógicos
terminal AND;
terminal OR;
terminal NOT;

//Delimitadores 
terminal OPEN_BRACKET;
terminal CLOSE_BRACKET;
terminal OPEN_CURLY_BRACKET;
terminal CLOSE_CURLY_BRACKET;
terminal OPEN_SQUARE_BRACKET;
terminal CLOSE_SQUARE_BRACKET;
terminal COMMA;
terminal COLON;
terminal SEMI_COLON;

//Palabras clave
terminal WHILE;
terminal IF;
terminal ELSE;
terminal INIT;
terminal TYPE_INT;
terminal TYPE_FLOAT;
terminal TYPE_STRING;
terminal READ;
terminal WRITE;

//Funciones especiales del lenguaje
terminal EQUAL_EXPRESSIONS;
terminal TRIANGLE_AREA_MAXIMUM;

//Constantes  
terminal String INTEGER_CONSTANT;
terminal String FLOAT_CONSTANT;
terminal String STRING_CONSTANT;
terminal String BOOLEAN_CONSTANT;

//Identificadores
terminal String IDENTIFIER;


// ----------------------------------------------------
// No terminales
// ----------------------------------------------------
non terminal program;
non terminal statements;
non terminal statement;
non terminal assignment;
non terminal if_statement;
non terminal else_clause;
non terminal while_statement;
non terminal read_statement;
non terminal write_statement;
non terminal expression;
non terminal term;
non terminal factor;
non terminal condition;
non terminal simple_condition;
non terminal compound_condition;
non terminal variable_declaration;
non terminal variable_declaration_list;
non terminal init_block;
non terminal String identifier_list;
non terminal type_specifier;
non terminal triangle;
non terminal point;
non terminal Object expression_list;
non terminal numeric_expression;
non terminal numeric_term;
non terminal numeric_factor;

// ----------------------------------------------------
// Start Symbol
// ----------------------------------------------------
start with program;

// ----------------------------------------------------
// Reglas del parser
// ----------------------------------------------------

program ::= statements 
                    {: 
                        System.out.println("Inicio del análisis");
                    :};

statements ::= /* vacío */ 
             | statements statement;

statement ::= assignment
            | if_statement
            | while_statement
            | read_statement
            | write_statement
            | init_block;   

assignment ::=  IDENTIFIER:id ASSIG expression:e
                    {: 
                        System.out.println("[ASSIGNMENT] Id := Expression -> " + id + " := " + e); 
                        if(!symbolTable.existsDynamic(id) && !symbolTable.exists(id)) throw new RuntimeException("Variable no declarada: " + id);
                        IntermediateCodeGenerator.addTerceto("ASSIGN", id, e);
                        RESULT = e;
                    :}
                |  IDENTIFIER:id ASSIG STRING_CONSTANT:strc
                    {:
                        System.out.println("[ASSIGNMENT] Id := String Constant -> " + id + " := " + strc); 
                        if(!symbolTable.existsDynamic(id) && !symbolTable.exists(id)) throw new RuntimeException("Variable no declarada: " + id);
                        IntermediateCodeGenerator.addTerceto("ASSIGN", id, strc);
                        RESULT = strc;
                    :};

if_statement ::=
                IF OPEN_BRACKET condition:c CLOSE_BRACKET
                    {:
                        IntermediateCodeGenerator.addTerceto("IF_FALSE", "[" + IntermediateCodeGenerator.getLastIndex() + "]", "[PENDIENTE]");
                        IntermediateCodeGenerator.pushSalto(IntermediateCodeGenerator.getLastIndex());  // guado indice
                    :}
                OPEN_CURLY_BRACKET statements CLOSE_CURLY_BRACKET
                else_clause
                    {:
                        if (!IntermediateCodeGenerator.isSaltoEmpty()) {
                            int tercetoPendiente = IntermediateCodeGenerator.popSalto();    
                            int finIfElse = IntermediateCodeGenerator.getNextIndex();
                            IntermediateCodeGenerator.completarSalto(tercetoPendiente, finIfElse);  
                        }
                    :};

else_clause ::= /* vacío */
                | ELSE
                    {:  
                        IntermediateCodeGenerator.addTerceto("BRANCH", null, "[PENDIENTE]");       
                        if (!IntermediateCodeGenerator.isSaltoEmpty()) {
                            int ifFalsePendiente = IntermediateCodeGenerator.popSalto();
                            int inicioElse = IntermediateCodeGenerator.getNextIndex();
                            IntermediateCodeGenerator.completarSalto(ifFalsePendiente, inicioElse);
                        }
                        IntermediateCodeGenerator.pushSalto(IntermediateCodeGenerator.getLastIndex());
                    :}
                OPEN_CURLY_BRACKET statements CLOSE_CURLY_BRACKET;                    


while_statement ::=
    WHILE
    {:
        IntermediateCodeGenerator.pushSalto(IntermediateCodeGenerator.getNextIndex());
    :}
    OPEN_BRACKET condition:cond CLOSE_BRACKET
    {:
        IntermediateCodeGenerator.addTerceto("IF_FALSE", "[" + IntermediateCodeGenerator.getLastIndex() + "]", "[PENDIENTE]");
        IntermediateCodeGenerator.pushSalto(IntermediateCodeGenerator.getLastIndex());
    :}
    OPEN_CURLY_BRACKET statements CLOSE_CURLY_BRACKET
    {:
        int ifFalsePendiente = IntermediateCodeGenerator.popSalto();
        int inicioWhile = IntermediateCodeGenerator.popSalto();
        IntermediateCodeGenerator.addTerceto("BRANCH", null, "[" + inicioWhile + "]");
        int finWhile = IntermediateCodeGenerator.getNextIndex();
        IntermediateCodeGenerator.completarSalto(ifFalsePendiente, finWhile);
    :};

read_statement ::= READ OPEN_BRACKET IDENTIFIER:id CLOSE_BRACKET 
                    {: 
                        System.out.println("[READ]  ( Identifier ): " + id); 
                        if(!symbolTable.existsDynamic(id) && !symbolTable.exists(id)) throw new RuntimeException("Variable no declarada: " + id);
                        IntermediateCodeGenerator.addTerceto("READ", id, null);
                    :};

write_statement ::= WRITE OPEN_BRACKET expression:exp CLOSE_BRACKET 
                    {: 
                        System.out.println("[WRITE] ( Expression ): " + exp); 
                        IntermediateCodeGenerator.addTerceto("WRITE", exp, null);
                    :} 
                | WRITE OPEN_BRACKET STRING_CONSTANT:sc CLOSE_BRACKET {: 
                        System.out.println("[WRITE] ( String Constante ): " + sc); 
                        IntermediateCodeGenerator.addTerceto("WRITE", sc, null);
                    :};

expression ::= expression:left PLUS term:right
                    {:
                        System.out.println("[EXPRESSION] Expresion + Term");
                        RESULT = IntermediateCodeGenerator.addTerceto("ADD", left, right);
                    :}
                | expression:left SUB term:right 
                    {: 
                        System.out.println("[EXPRESSION] Expresion - Term"); 
                        RESULT = IntermediateCodeGenerator.addTerceto("SUB", left, right);
                    :}
                | term:term
                    {: 
                        System.out.println("[EXPRESSION] Term"); 
                        RESULT = term;
                    :}
                | TRIANGLE_AREA_MAXIMUM OPEN_BRACKET triangle:t1 SEMI_COLON triangle:t2 CLOSE_BRACKET 
                    {: 
                        System.out.println("[EXPRESSION] triangleAreaMaximum ( Triangle ; Triangle )");
                        Object t1_area = IntermediateCodeGenerator.addTerceto("AREA", t1, null);
                        Object t2_area = IntermediateCodeGenerator.addTerceto("AREA", t2, null);
                        RESULT = IntermediateCodeGenerator.addTerceto("MAX", t1_area, t2_area);
                    :}
                | EQUAL_EXPRESSIONS OPEN_BRACKET expression_list:el CLOSE_BRACKET
                    {: 
                        String res = lyc.compiler.files.ExpressionUtils.equalExpressions(el);
                        System.out.println("[EXPRESSION] equalExpressions ( Expression List ): " + el);
                        RESULT = res;
                    :};

triangle ::= OPEN_SQUARE_BRACKET point:p1 SEMI_COLON point:p2 SEMI_COLON point:p3 CLOSE_SQUARE_BRACKET 
                    {: 
                        System.out.println("[TRIANGLE] [point ; point ; point ]");
                        Object temp_tri = IntermediateCodeGenerator.addTerceto("TRI_P1_P2", p1, p2);
                        RESULT = IntermediateCodeGenerator.addTerceto("TRIANGLE", temp_tri, p3);
                    :};

point ::= numeric_expression:x COMMA numeric_expression:y 
                    {: 
                        System.out.println("[POINT] Numeric Expression , Numeric Expression");
                        RESULT = IntermediateCodeGenerator.addTerceto("POINT", x, y);
                    :};

expression_list ::= expression:exp
                    {: 
                        System.out.println("[EXPRESSION LIST] Expression");
                        java.util.List<Object> list = new java.util.ArrayList<>();
                        list.add(exp);
                        RESULT = list;
                    :}
                | expression_list:list COMMA expression:exp
                    {: 
                        System.out.println("[EXPRESSION LIST] Expression List , Expression");
                        java.util.List<Object> tmp = (java.util.List<Object>) list;
                        tmp.add(exp);
                        RESULT = tmp;
                    :};

term ::= term:left MULT factor:right 
                    {: 
                        System.out.println("[TERM] Term * Factor"); 
                        RESULT = IntermediateCodeGenerator.addTerceto("MULT", left, right);
                    :}
                | term:left DIV factor:right 
                    {: 
                        System.out.println("[TERM] Term / Factor"); 
                        RESULT = IntermediateCodeGenerator.addTerceto("DIV", left, right);
                    :}
                | factor:value 
                    {: 
                        System.out.println("[TERM] Factor");
                        RESULT = value; 
                    :};

factor ::= IDENTIFIER:id 
                    {: 
                        System.out.println("[FACTOR] Identificador: " + id);
                        RESULT = id;
                    :}
                | INTEGER_CONSTANT:intc {: 
                        System.out.println("[FACTOR] Constante Entera: " + intc);
                        RESULT = intc;
                    :}
                | FLOAT_CONSTANT:floatc 
                    {: 
                        System.out.println("[FACTOR] Constante Float: " + floatc);
                        RESULT = floatc;
                    :}
                | OPEN_BRACKET expression:exp CLOSE_BRACKET 
                    {: 
                        System.out.println("[FACTOR] ( Expression )"); 
                        RESULT = "(" + exp + ")"; 
                    :};

// Numeric-only expressions
numeric_expression ::= numeric_expression:left PLUS numeric_term:right 
                    {: 
                        System.out.println("[NUMERIC EXPRESSION] Numeric Expression + Numeric Term");
                        RESULT = IntermediateCodeGenerator.addTerceto("ADD", left, right);
                    :}
                | numeric_expression:left SUB numeric_term:right 
                    {: 
                        System.out.println("[NUMERIC EXPRESSION] Numeric Expression - Numeric Term");
                        RESULT = IntermediateCodeGenerator.addTerceto("SUB", left, right);
                    :}
                | numeric_term:term 
                    {: 
                        System.out.println("[NUMERIC EXPRESSION] Numeric Term");
                        RESULT = term; 
                    :};

numeric_term ::= numeric_term:left MULT numeric_factor:right 
                    {: 
                        System.out.println("[NUMERIC TERM] Numeric Term * Numeric Factor");
                        RESULT = IntermediateCodeGenerator.addTerceto("MULT", left, right);
                    :}
                | numeric_term:left DIV numeric_factor:right 
                    {: 
                        System.out.println("[NUMERIC TERM] Numeric Term / Numeric Factor");
                        RESULT = IntermediateCodeGenerator.addTerceto("DIV", left, right);
                    :}
                | numeric_factor:value 
                    {: 
                        System.out.println("[NUMERIC TERM] Numeric Factor");
                        RESULT = value; 
                    :};

numeric_factor ::= IDENTIFIER:id 
                    {: 
                        System.out.println("[NUMERIC FACTOR] Identifier: " + id);
                        RESULT = id; 
                    :}
                | INTEGER_CONSTANT:intc 
                    {: 
                        System.out.println("[NUMERIC FACTOR]  Integer Constant: " + intc);
                        RESULT = intc; 
                    :}
                | FLOAT_CONSTANT:floatc 
                    {: 
                        System.out.println("[NUMERIC FACTOR] Float Constant: " + floatc);
                        RESULT = floatc; 
                    :}
                | OPEN_BRACKET numeric_expression:exp CLOSE_BRACKET 
                    {: 
                        System.out.println("[NUMERIC FACTOR] Numeric Expression: " + exp);
                        RESULT = exp; 
                    :};

condition ::= simple_condition
                | NOT simple_condition 
                    {: 
                        System.out.println("[CONDITION] NOT Simple Condition"); 
                    :}
                | compound_condition 
                    {: 
                        System.out.println("[CONDITION] Compound Condition"); 
                    :};

simple_condition ::= numeric_expression:left LESS numeric_expression:right
                    {: 
                        System.out.println("[SIMPLE CONDITION] Expression < Expression"); 
                        RESULT = IntermediateCodeGenerator.addTerceto("LESS", left, right);
                    :}
                | numeric_expression:left GREATER numeric_expression:right
                    {: 
                        System.out.println("[SIMPLE CONDITION] Expression > Expression"); 
                        RESULT = IntermediateCodeGenerator.addTerceto("GREATER", left, right);
                    :}
                | numeric_expression:left EQUAL numeric_expression:right
                    {: 
                        System.out.println("[SIMPLE CONDITION] Expression == Expression");
                        RESULT = IntermediateCodeGenerator.addTerceto("EQUAL", left, right);
                    :}
                | numeric_expression:left NOT_EQUAL numeric_expression:right
                    {: 
                        System.out.println("[SIMPLE CONDITION] Expression != Expression"); 
                        RESULT = IntermediateCodeGenerator.addTerceto("NOT_EQUAL", left, right);
                    :}
                | numeric_expression:left LESS_EQUAL numeric_expression:right
                    {: 
                        System.out.println("[SIMPLE CONDITION] Expression <= Expression"); 
                        RESULT = IntermediateCodeGenerator.addTerceto("LESS_EQUAL", left, right);
                    :}
                | numeric_expression:left GREATER_EQUAL numeric_expression:right
                    {: 
                        System.out.println("[SIMPLE CONDITION] Expression >= Expression"); 
                        RESULT = IntermediateCodeGenerator.addTerceto("GREATER_EQUAL", left, right);
                    :};

compound_condition ::= simple_condition:left AND simple_condition:right 
                    {: 
                        System.out.println("[COMPOUND CONDITION] Condition AND Condition"); 
                        //if (!lyc.compiler.files.Utils.isBoolean(left) || !lyc.compiler.files.Utils.isBoolean(right)) throw new RuntimeException("Operador AND aplicado a expresiones no booleanas");
                    :}
                | simple_condition:left OR simple_condition:right
                    {: 
                        System.out.println("[COMPOUND CONDITION] Condition OR Condition");
                        //if (!lyc.compiler.files.Utils.isBoolean(left) || !lyc.compiler.files.Utils.isBoolean(right)) throw new RuntimeException("Operador AND aplicado a expresiones no booleanas"); 
                    :};

init_block ::= INIT OPEN_CURLY_BRACKET variable_declaration_list CLOSE_CURLY_BRACKET 
                    {: 
                        System.out.println("[INIT BLOCK] Init { variable_declaration_list }"); 
                    :};

variable_declaration ::= identifier_list:list COLON type_specifier:type 
                    {: 
                        System.out.println("[VARIABLE DECLARATION] identifier_list : type_specifier");
                        String[] ids = ((String)list).split(",");
                        for(String id : ids){
                            if(id.length() > lyc.compiler.constants.Constants.STRING_MAX_LENGTH) throw new RuntimeException("Nombre de identificador demasiado largo: " + id);
                            if(symbolTable.existsDynamic(id)) throw new RuntimeException("Variable ya declarada: " + id);
                            symbolTable.insertVariablesDynamic(id, type);
                            symbolTable.updateVariable(id, type);
                        }
                    :};

variable_declaration_list ::= variable_declaration
                    {: 
                        System.out.println("[VAR DECLARATION LIST] variable_declaration");
                    :}
                | variable_declaration_list variable_declaration
                    {: 
                        System.out.println("[VAR DECLARATION LIST] variable_declaration_list variable_declaration");
                    :};

identifier_list ::= IDENTIFIER:id 
                    {: 
                        System.out.println("[IDENTIFIER LIST] Identifier");
                        if(id.length() > lyc.compiler.constants.Constants.STRING_MAX_LENGTH) 
                            throw new RuntimeException("Nombre de identificador demasiado largo: " + id); 
                        RESULT = id; 
                    :}
                | identifier_list:list COMMA IDENTIFIER:id 
                    {: 
                        System.out.println("[IDENTIFIER LIST] identifier_list , Identifier");
                        if(id.length() > lyc.compiler.constants.Constants.STRING_MAX_LENGTH) 
                            throw new RuntimeException("Nombre de identificador demasiado largo: " + id); 
                        RESULT = list + "," + id; 
                    :};

type_specifier ::= TYPE_INT 
                    {: 
                        System.out.println("[TYPE SPECIFIER] Type Integer" );
                        RESULT = "Int"; 
                    :}
                | TYPE_FLOAT 
                    {: 
                        System.out.println("[TYPE SPECIFIER] Type Float" );
                        RESULT = "Float"; 
                    :}
                | TYPE_STRING 
                    {: 
                        System.out.println("[TYPE SPECIFIER] Type String" );
                        RESULT = "String"; 
                    :};